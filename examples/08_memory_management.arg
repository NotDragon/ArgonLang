// Memory management: pointers, references, ownership
func memoryExample() {
    // Raw pointer
    def rawPtr: *i32;
    
    // Owned pointer (unique_ptr equivalent)
    def uniquePtr: ~i32 = 42;
    
    // Shared reference (shared_ptr equivalent)
    def sharedPtr: ref<i32>;
    
    // Weak reference
    def weakPtr: weak<i32>;
    
    // Immutable reference
    def value: i32 = 100;
    def immutableRef: &i32 = &value;
    
    // Mutable reference
    def mutableRef: &&i32 = &&value;
}

func borrowingExample(data: &vec<i32>) i32 {
    // Function takes immutable reference
    return data[0];
}

func mutatingExample(data: &&vec<i32>) {
    // Function takes mutable reference
    data.push(42);
}

func ownershipExample(data: ~vec<i32>) vec<i32> {
    // Function takes ownership
    return *data;
}

class DataContainer {
    pub def data: ~vec<i32>;
    
    pub constructor() {
        this.data = ~vec<i32>();
    }
    
    pub func addData(value: i32) mut {
        this.data.push(value);
    }
    
    pub func getData() &vec<i32> {
        return &this.data;
    }
}

func main() i32 {
    memoryExample();
    
    def container: DataContainer = DataContainer();
    container.addData(10);
    container.addData(20);
    
    def dataRef: &vec<i32> = container.getData();
    def firstValue: i32 = borrowingExample(dataRef);
    
    return 0;
}
